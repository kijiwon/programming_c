1. 자료형 - 변수에 저장할 데이터의 종류와 범위
    •문자형
        char(1byte)-글자 1개(한글은 제외)
        unsigned char(1byte)
    •정수형
        short(2byte)
        ⭐️ int(4byte)
        long(4byte)
        long long(8byte)
    •실수형
        ⭐️ float(4byte)
        ⭐️ double(8byte)
        long double(12~16byte)

2. 변수 - 값이 저장되는 기억 공간
    ◼︎ 변수명 작성 규칙
        •영문자 또는 언더바로 시작(Not 숫자)
        •공백 사용할 수 없음
        •언더바를 제외한 특수문자 사용할 수 없음
        •예약어는 사용할 수 없음
    ◼︎ 변수의 종류
        1) 지역변수 - 함수 내부나 중괄호 내부에서 선언
            유효범위: 함수 내부 또는 중괄호 내부
        2) 전역변수 - 전처리기 아래에 선언
            유효범위: 전 범위. 모든 함수에서 공통으로 사용
        3) 정적변수 - static 키워드로 선언
            유효범위: 선언된 함수 내부
        4) 동적변수 - 프로그램 실행 도중 동적으로 메모리를 할당받음
            malloc 함수 등을 이용해 메모리 공간 확보
        5) 외부변수 - 다른 파일에서 선언된 전역변수를 참조
            extern 키워드를 사용해 외부 파일의 전역변수를 참조

3. 입출력 함수
    •표준 출력 함수
        printf()
        putchar() - 한 개의 문자 출력
        puts() - 문자열 출력
    •표준 입력 함수
        scanf() - 키보드를 통해 한 개 이상의 자료를 입력받음
        getchar() - 한 개의 문자를 입력받음
        gets() - 문자열을 입력받음
    •출력 변환 문자
        %d: 10진수
        %o: 8진수
        %x: 16진수
        %f: 실수
        %c: 문자 1개 printf("%c", 'A');
        %s: 문자열 printf("%s", "ABC")
    •이스케이프 시퀀스
        \n: 다음 줄로 이동
        \t: 수평 탭 간격만큼 이동
        \r: 현재 줄의 맨 앞으로 이동
        \b: 왼쪽으로 한 칸 이동(백스페이스)
        \f: 다음 페이지로 넘김
        \': 작은 따옴표 출력
        \": 큰 따옴표 출력
    ✏️사용 예시
    int main(){
        char c;
        c = getchar(); →입력값 대입 A
        printf("%d\n", c); → c를 10진수로 출력 A를 아스키코드로 변환하면 65
        printf("%c\n", c); → c를 문자로 출력 A
        putchar('A'); → A를 출력 A
        printf("\n"); → 줄바꿈
        putchar(65); → 65를 문자로 변환(아스키코드) A
        return 0;
    }
    [실행 결과]
    65
    A
    A
    A

4. 연산자
    •산술 연산자
        +
        -
        *
        /
        %
        ++
        --
    •관계 연산자
        >
        <
        >=, <=
        ==
        !=
    •논리 연산자
        && - AND
        || - OR
        ! - NOT
    •비트 연산자
        & - 비트 AND
        | - 비트 OR
        ~ - 비트 not: -1한 후 앞에 -부호를 붙임
        ^ - 비트 XOR: 두 자리가 같으면 0, 다르면 1
        << - 좌 비트 이동: 숫자만큼 비트 추가 ex) 10<<2 -> 1010뒤에 00추가 -> 101000 -> 40
        >> - 우 비트 이동: 숫자만큼 비트 제거 ex) 10>>2 -> 1010뒤에 두 비트 제거 -> 10 -> 2
    •삼항 연산자
        ? :
    •대입 연산자
        +=
        -=
        *=
        /=
        %=
    •연산자 우선순위
        ➀단항 연산자: ++, --, !
        ➁산술 연산자: +, -, *, /
        ➂시프트 연산자: <<, >>
        ➃관계 연산자: >, <, >=, <=, ==, !=
        ➄비트 연산자: &, |, ^
        ➅논리 연산자: &&, ||
        ➆삼항 연산자: ? :
        ➇대입 연산자: =, +=, -=, *=,/=, %=

5. 제어문
    ◼︎ if
        •단순 if문
            if(조건){ 조건이 참일 때 실행할 함수 }
        •if else문
            if(조건){ 조건이 참일 때 실행할 함수 } else{ 조건이 거짓일 때 실행할 함수}
        •다중 if문
            if(조건1){
                조건1이 참일 때 실행할 함수
            } else if(조건2){
                조건2가 참일 때 실행할 함수
            } else if(조건3){
                조건3이 참일 때 실행할 함수
            } else{ 
                조건이 모두 거짓일 때 실행할 함수
            }
    ◼︎ switch
        switch(변수){
            case 값1:
                명령문;
                break;
            case 값2:
                명령문;
                break;
            default:
                명령문;
        }
        ❗️ break를 넣어주지 않을 경우 뒤에 오는 모든 함수를 실행
        
6. 반복문
    ◼︎ for 문 - 반복 횟수가 정해진 경우 가장 적합
        for(초기식; 조건식; 증감식){ 반복 실행할 코드 }
        •초기식: 반복 제어 변수의 초기값 설정
        •조건식: 참인 경우 본문 실행, 거짓인 경우 반복문 종료
        •증감식: 반복 제어 변수의 값 변화. ❗️반복이 끝날 때마다 실행
    ◼︎ while 문 - 반복 횟수가 정해지지 않은 경우 적합
        while(조건식){ 반복 실행할 코드 }
        •조건식: 참인 경우 본문 실행, 거짓인 경우 반복문 종료
        •본문: 본문 실행 후 조건식이 다시 평가됨 → 반복 제어 변수의 값을 변화시키는 코드 필요(ex. 증감식)
    ◼︎ do~while문 - 최소 한 번은 본문 실행
        do { 반복 실행할 코드 } while(조건식)
        •본문: 항상 처음 한 번은 실행됨
        •조건식: 본문 실행 후 조건 평가. 참인 경우 본문 실행, 거짓인 경우 반복문 종료
    ◼︎ continue 문 - 반복문의 나머지 코드를 건너뛰고 다음 반복문으로 이동→반복문의 조건 확인 단계로 이동
        for(초기식; 조건식; 증감식){
            if(조건){
                continue; → 조건이 참인 경우 아래 코드를 건너뜀
            }
            조건이 만족되는 경우 실행되지 않음
        }
        • 중첩 반복문에서의 continue
        int main(){
            for(int i = 0; i < 3; i++){
                for(int j = 0; j < 3; j++){
                    if(j == 1){
                        continue;
                    }
                    printf("i: %d, j: %d\n", i, j);
                }
            }
            return 0;
        }

        [실행 결과]
        i: 0, j: 0
        i: 0, j: 2
        i: 1, j: 0
        i: 1, j: 2
        i: 2, j: 0
        i: 2, j: 2
        
    ◼︎ break 문 - 반복문을 즉시 종료시킴
        for(초기식; 조건식; 증감식){
            if(조건){
                break; → 조건이 참인 경우 반복문 종료
            }
            break를 만나지 않은 경우에만 실행
        }
        • 중첩 반복문에서의 break
        int main(){
            for(int i = 0; i < 3; i++){
                for(int j = 0; j < 3; j++){
                    if(j == 1){
                        break;
                    }
                    printf("i: %d, j: %d\n", i, j);
                }
            }
            return 0;
        }

        [실행 결과]
        i: 0, j: 0
        i: 1, j: 0
        i: 2, j: 0

7. 함수 - 반복적으로 수행해야 하는 작업. 코드의 재사용성과 가독성을 높임
    반환형 함수명(매개변수 목록){
        실행할 코드
    }
    ◼︎ 종류
        •사용자 정의 함수 - 사용자가 특정 기능을 정의
        •표준 함수(라이브러리 함수) - C언어의 표준으로 제공되는 함수. #include 지시문으로 호출
    ◼︎ 자료의 전달 방법
        •값에 의한 호출: 값을 복사해 전달. 원본 변수와 복사된 변수는 별개의 메모리 공간을 사용 → 원본 변수에는 영향을 미치지 않음
        •참조에 의한 호출: 함수 호출 시 변수의 주소값을 전달 → 원본 변수의 값을 직접 수정. 전달된 변수와 매개변수는 같은 메모리 공간을 참조
            ex.
            #include <stdio.h>
            void add(int *a){
                (*a)++;
                printf("add: %d\n", *a); 
            }
            int main(){
                int x = 5;
                add(&x);
                printf("main: %d\n", x);
                return 0;
            }

            [실행 결과]
            add: 6
            main: 6

8. 변수의 유효범위
    •지역변수: 함수 또는 블록 내부에서 선언된 변수
        해당 블록 내에서만 유효. 블록이 종료되면 메모리에서 사라짐
    •전역변수: 함수 외부에서 선언된 변수
        프로그램 전체에서 접근 가능, 모든 함수에서 공유됨. 프로그램이 종료될 때까지 메모리에 유지됨
    •정적변수: static 키워드로 선언된 변수
        선언된 블록 내에서만 유효. 프로그램이 종료될 때까지 메모리에 유지됨
    •매개변수: 함수 호출 시 전달된 값을 저장하는 임시 변수
        함수 내부에서만 유효. 함수가 종료되면 메모리에서 사라짐

9. 재귀함수 - 함수 내부에서 자기 자신을 다시 호출하는 함수
    ❗️ 반드시 종료 조건이 있어야 한다.
    •예제 - 피보나치 수열
    int fibonacci(int n){
        if(n == 0 || n == 1) return n; // 기저 조건
        return fibonacci(n - 1) + fibonacci(n - 2); // 재귀 호출
    }

10. 선행 처리기 - 컴파일 이전 단계에서 프로그램 상단에 선언된 지시자(Directive)를 처리
    •주요 기능
        ➀ 매크로 처리: 반복적으로 사용되는 값 또는 간단한 코드 조각을 매크로로 정의하여 사용
            ex) #define PI 3.14
        ➁ 파일 포함: 다른 파일을 현재 소스 코드에 포함시킴
            ex) #include <stdio.h>
        ➂ 조건부 컴파일: 특정 조건에 따라 코드의 일부를 포함하거나 제외함
        ➃ 문자열 치환: 매크로로 정의된 심볼 이름을 해당 값으로 치환
            ex) #define SQUARE(x) ((x) * (x))
    ◼︎ 매크로 정의
        매크로: 선행 처리기에서 #define을 사용해 단순 치환되는 자료
        •종류
            - 매크로 상수: 미리 정의한 매크로 상수명이 프로그램에서 사용될 경우 매크로 확장 문자열로 치환
            - 매크로 함수: 전달된 인자의 형태를 가지고 치환하는 동작
    ◼︎조건부 컴파일: 조건이 만족될 때 특정 코드를 컴파일
        •조건부 컴파일 구문
            - #if 조건: 조건이 참일 때 컴파일 수행될 문장
            - #else: 조건이 거짓일 때 컴파일 수행될 문장
            - #elif: #else와 #if가 같이 있는 문장
            - #endif: 조건의 끝이 되는 문장

11. 배열과 포인터
    ◼︎ 배열: 동일한 자료형으로 이루어진 물리적으로 연속된 메모리 공간
        - 배열 요소: 배열을 구성하는 각각의 값
        - 인덱스: 배열 요소의 위치
        
        ○ 배열의 선언
            •1차원 배열
                int a [5];
            •2차원 배열
                int a [3][3];
            •배열과 초기화
                int arr[3]; → 3개의 요소 공간 생성, 초기값은 쓰레기값
                int arr[3] = {} → 3개의 요소를 0으로 초기화
                int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8}; → 9개의 공간에 순차적으로 초기값 지정, 빈 공간은 쓰레기값

    ◼︎ 포인터 변수: 변수의 메모리 주소를 저장하는 변수 → 메모리 주소를 저장해 해당 주소에 있는 데이터를 참조 및 수정할 수 있음
        ○ 포인터 변수의 선언과 초기화
            •선언 - 자료형 뒤에 *를 붙여 선언
                int* ptr;
            •초기화 - 변수의 주소를 저장
                int a = 10;
                int* ptr = &a; // 변수 a의 주소를 저장
        ○ 포인터 변수의 기본 동작
            •주소 연산자(&): 변수의 메모리 주소를 가져옴
            •역참조 연산자(*): 포인터가 가리키는 주소의 값을 참조하거나 수정
        ○포인터 변수 예제
            •값 변경
                int a = 10;
                int* ptr = &a;
                *ptr = 20;
                printf("%d\n", a); // 20
            •배열 처리
                int arr[3] = {1, 2, 3};
                int* ptr = arr; // 배열의 첫 번째 요소의 주소 저장
                printf("%d\n", *(ptr+1)); // 두 번째 요소의 주소 → 2
            •이중 포인터
                int a = 10;
                int* ptr = &a;
                int** dptr = &ptr; // ptr을 가리키는 이중 포인터
                printf("%d\n", a); // 10
                printf("%d\n", *ptr); // 10
                printf("%d\n", **dptr); // 10
    
    ◼︎ 포인터 배열: 배열의 요소가 포인터(메모리 주소)로 이루어진 배열
        •선언 및 초기화
            자료형* 배열명[크기];
                int a = 10, b = 20, c = 30;
                int* arr[3] = {&a, &b, &c};
    
    ◼︎ 배열 포인터: 배열의 시작 주소를 저장할 수 있는 포인터. 배열의 전체를 가리킴 ❗️ NOT 요소
        •선언
            자료형 (*포인터명)[배열크기];
            int (*ptr)[3];
        •초기화 - 배열의 시작 주소를 저장
            int arr[3] = {10, 20, 30};
            int (*ptr)[3] = &arr; // arr의 시작 주소(배열 전체의 시작 주소)를 저장
    
⭐️ 배열 주소값 정리 ⭐️
    int a[5] = {1, 2, 3, 4, 5};
    배열의 첫 번째 주소를 100번지라 가정
    a → 100
    &a → 100
    &a[0] → 첫 번째 요소의 주소 100
    a+1 → a[1]의 주소 -> 104 (int는 4byte)
    &a[0]+1 → a[0]의 다음 공간(a[1])의 주소 -> 104
    &a+1 → a주소의 다음 공간(전체 주소의 다음 공간) 120(a의 전체 크기는 5 * 4byte = 20byte)

    int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
    배열의 첫 번째 주소를 100번지라 가정
    a → 100
    &a → 100
    a[0] → 배열 첫 번째 행의 시작 주소(a[0][0]) 100
    *a → 첫 번째 행의 시작 주소 100
    a[0]+1 → 첫 번째 행의 두 번째 요소(a[0][1])의 주소 104
    *a+1 → 첫 번째 행의 두 번째 요소 주소(a[0][1]) 104
    &a[0][0]+1 → 첫 번째 요소의 다음 요소의 주소(a[0][1]) 104
    ⭐️ &a[0]+1 → 다음 행(두 번째 행)의 시작 주소(a[1][0]) 112
    a+1 → 다음 행(두 번째 행)의 시작 주소(a[1][0]) 112
    &a+1 → 전체 배열의 다음 위치의 주소(3*4*2 = 124) 124

12. 구조체 - 다양한 자료형으로 이루어진 데이터를 하나의 단위로 묶는 사용자 정의 자료형
    •선언 및 정의 - struct 키워드를 사용해 선언
        struct Student {
            char name[50];
            int age;
            float grade;
        };
    •구조체 변수 선언 - 구조체 변수를 선언해 데이터를 저장
        struct Student {
            char name[50];
            int age;
            float grade;
        };
        struct Student s1, s2;
    •구조체 변수 초기화 - 선언 시 초기화하거나 이후에 값을 할당
        struct Student {
            char name[50];
            int age;
            float grade;
        };
        struct Student s1 = {"Lee", 45, 3.5}; // 순서대로 할당
    •구조체 멤버 접근 - 점 연산자(.)를 사용
        struct Student s1 = {"Lee", 45, 3.5};
        printf("Name: %s\n", s1.name); // Name: Lee
    •구조체 배열 - 배열로 선언해 여러 데이터를 저장할 수 있음
        struct Student {
            char name[50];
            int age;
            float grade;
        };
        int main(){
            struct Student st[3] = {
                {"Lee", 17, 2.8},
                {"Kim", 19, 3.5},
                {"Park", 20, 4.0}
            };
            for(int i = 0; i < 3; i++){
                printf("%s, %d, %.2f\n", st[i].name, st[i].age, st[i].grade);
            }
            return 0;
        }
    •구조체 포인터 - 구조체를 포인터로 사용. 화살표 연산자(→)를 사용해 멤버에 접근
        struct Student {
            char name[50];
            int age;
            float grade;
        };
        int main() {
            struct Student s1 = {"Lee", 18, 2.5};
            struct Student *ptr = &s1; // s1의 주소를 할당
            printf("%s\n", ptr→name); // Lee
            return 0;
        }
    •typedef와 구조체 - typedef를 사용해 구조체에 별칭을 붙이면 struct 키워드 없이 구조체를 사용할 수 있음
        int main(){
        typedef struct {
            char name[50];
            int age;
            float grade;
        } Student;
        Student s1 = {"Lee", 18, 2.5};
        }
    •중첩 구조체 - 구조체 안에 또 다른 구조체를 포함
        int main() {
            struct Address {
                char city[50];
                int zipCode;
            };
            struct Person {
                char name[50];
                struct Address address; // 중첩 구조체
            };
        }

13. 공용체 - 여러 멤버를 정의. 가장 큰 멤버의 크기만큼의 메모리만 할당
    하나의 메모리 공간을 공유하기 때문에 한 시점에 하나의 멤버만 값을 저장
    •선언 및 정의 - union 키워드를 사용해 선언
        union Data {
            int i; // 4byte
            float f; // 4byte
            char str[20]; // 20byte
        }; → 20byte 크기를 가진 공용체

14. 프로세스 생성
    ◼︎ fork: 새로운 프로세스(자식 프로세스)를 생성하기 위해 부모 프로세스를 복제하여 동일한 메모리 공간을 부여
        부모와 자식 프로세스는 동일한 코드를 실행하지만 프로세스 ID(PID)를 통해 구분
        ○동작 방식
            •fork()는 호출 시 두 번 반환
                - 부모 프로세스에서는 자식 프로세스의 PID 반환(양수)
                - 자식 프로세스에서는 0을 반환
                - 프로세스 생성 실패 시 음수 반환
        ○활용 예시
            #include <stdio.h>
            #include <unistd.h>

            int main() {
                pid_t pid = fork(); // pid_t → 프로세스 ID를 받을 수 있는 자료형
                if(pid > 0) { // 부모 프로세스
                    printf("P PID = %d, C PID = %d\n", getpid(), pid);
                } else if(pid == 0) { // 자식 프로세스
                    printf("C PID = %d\n", getpid());
                } else { // 프로세스 실패
                    printf("Fork failed.\n");
                }
                return 0;
            }

15. C언어 주요 함수
    ◼︎ 문자열 함수 <string.h>
        •strlen(a): a 문자열의 길이를 반환
        •strcpy(a, b): a에 b 문자열을 복사
        •strncpy(a, b, n): a에 b 문자열을 n번째 인덱스 앞까지 복사
        •strcat(a, b): a 문자열 뒤에 b 문자열을 이어 붙임
        •strncat(a, b, n): a 문자열 뒤에 b 문자열의 n번째 인덱스 앞까지 이어 붙임
        •strcmp(a, b): a 문자열과 b 문자열을 비교. 같으면 0, a가 크면 양수, b가 크면 음수(아스키코드 기준으로 비교)
        •strncmp(a, b, n): a 문자열과 b 문자열을 n개 만큼 비교. 같으면 0, a가 크면 양수, b가 크면 음수(아스키코드 기준으로 비교)
        •strchr(a, b): a 문자열에서 b 문자가 나타나는 첫 번째 위치를 반환. 없다면 null 반환
        •strrchr(a, b): a 문자열에서 b 문자가 나타나는 마지막 위치를 반환. 없다면 null 반환
        •strstr(a, b): a 문자열에서 b 문자열의 첫 번째 위치를 반환. 없다면 null 반환
        
    ◼︎ 수학 함수 <Math.h>
        •sqrt(a): a의 제곱근을 반환
        •pow(a): a의 거듭제곱을 반환
        •abs(a): 정수 a의 절대값을 반환
        •ceil(a): 올림 ex. printf("%.1f", ceil(2.1)); // 3
        •floor(a): 내림 ex. printf("%.1f", floor(2.6)); // 2
    
    ◼︎ 자주 사용되는 함수
        •atoi(a) / atof(a): a 문자열을 정수/실수로 변환. ❗️ 숫자가 아닐 경우 오류 발생 ex."123"
        •rand() / srand(): 난수 생성
        •toupper(a) / tolower(a): a 문자열을 대문자/소문자로 변환
